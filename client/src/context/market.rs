//! Market-level context for creating markets, managing seats, and building `dropset` market
//! instructions.

use dropset_interface::{
    instructions::generated_client::*,
    seeds::event_authority,
    state::{
        sector::NIL,
        SYSTEM_PROGRAM_ID,
    },
};
use solana_instruction::Instruction;
use solana_sdk::pubkey::Pubkey;

use crate::{
    context::token::TokenContext,
    pda::find_market_address,
    transactions::CustomRpcClient,
    views::{
        view_market_account,
        MarketSeatView,
        MarketView,
    },
};

/// A struct containing contextual fields for a market.
///
/// Implements helper methods for all program instructions using those values.
pub struct MarketContext {
    pub market: Pubkey,
    pub base: TokenContext,
    pub quote: TokenContext,
    pub base_market_ata: Pubkey,
    pub quote_market_ata: Pubkey,
}

impl MarketContext {
    /// Creates a market with random tokens generated by airdropping funds.
    pub async fn new_market(rpc: &CustomRpcClient) -> anyhow::Result<Self> {
        let base = TokenContext::new_token(rpc, None).await?;
        let quote = TokenContext::new_token(rpc, None).await?;
        let (market_address, _bump) = find_market_address(&base.mint, &quote.mint);
        let base_market_ata = base.get_ata_for(&market_address);
        let quote_market_ata = quote.get_ata_for(&market_address);
        Ok(Self {
            market: market_address,
            base,
            quote,
            base_market_ata,
            quote_market_ata,
        })
    }

    pub fn get_base_ata(&self, owner: &Pubkey) -> Pubkey {
        self.base.get_ata_for(owner)
    }

    pub fn get_quote_ata(&self, owner: &Pubkey) -> Pubkey {
        self.quote.get_ata_for(owner)
    }

    /// Creates a seat for the user by depositing the minimum amount required to create a seat.
    ///
    /// This is because the amount cannot be zero:
    /// [`dropset_interface::error::DropsetError::AmountCannotBeZero`]
    pub fn create_seat(&self, user: Pubkey) -> Instruction {
        self.deposit_base(user, 1, NIL)
    }

    pub fn register_market(&self, payer: Pubkey, num_sectors: u16) -> Instruction {
        RegisterMarket {
            event_authority: event_authority::ID.into(),
            user: payer,
            market_account: self.market,
            base_market_ata: self.base_market_ata,
            quote_market_ata: self.quote_market_ata,
            base_mint: self.base.mint,
            quote_mint: self.quote.mint,
            base_token_program: self.base.token_program,
            quote_token_program: self.quote.token_program,
            ata_program: spl_associated_token_account_interface::program::ID,
            system_program: SYSTEM_PROGRAM_ID.into(),
        }
        .create_instruction(RegisterMarketInstructionData::new(num_sectors))
    }

    pub fn view_market(&self, rpc: &CustomRpcClient) -> anyhow::Result<MarketView<MarketSeatView>> {
        view_market_account(rpc, &self.market)
    }

    pub fn find_seat(
        &self,
        rpc: &CustomRpcClient,
        user: &Pubkey,
    ) -> anyhow::Result<Option<MarketSeatView>> {
        let market = self.view_market(rpc)?;
        Ok(market.sectors.into_iter().find(|seat| &seat.user == user))
    }

    pub fn close_seat(&self, user: Pubkey, sector_index_hint: u32) -> Instruction {
        CloseSeat {
            event_authority: event_authority::ID.into(),
            user,
            market_account: self.market,
            base_user_ata: self.get_base_ata(&user),
            quote_user_ata: self.get_quote_ata(&user),
            base_market_ata: self.base_market_ata,
            quote_market_ata: self.quote_market_ata,
            base_mint: self.base.mint,
            quote_mint: self.quote.mint,
            base_token_program: self.base.token_program,
            quote_token_program: self.quote.token_program,
        }
        .create_instruction(CloseSeatInstructionData::new(sector_index_hint))
    }

    pub fn deposit_base(&self, user: Pubkey, amount: u64, sector_index_hint: u32) -> Instruction {
        let data = DepositInstructionData::new(amount, sector_index_hint);
        self.deposit(user, data, true)
    }

    pub fn deposit_quote(&self, user: Pubkey, amount: u64, sector_index_hint: u32) -> Instruction {
        let data = DepositInstructionData::new(amount, sector_index_hint);
        self.deposit(user, data, false)
    }

    pub fn withdraw_base(&self, user: Pubkey, amount: u64, sector_index_hint: u32) -> Instruction {
        let data = WithdrawInstructionData::new(amount, sector_index_hint);
        self.withdraw(user, data, true)
    }

    pub fn withdraw_quote(&self, user: Pubkey, amount: u64, sector_index_hint: u32) -> Instruction {
        let data = WithdrawInstructionData::new(amount, sector_index_hint);
        self.withdraw(user, data, false)
    }

    fn deposit(&self, user: Pubkey, data: DepositInstructionData, is_base: bool) -> Instruction {
        match is_base {
            true => Deposit {
                event_authority: event_authority::ID.into(),
                user,
                market_account: self.market,
                user_ata: self.get_base_ata(&user),
                market_ata: self.base_market_ata,
                mint: self.base.mint,
                token_program: self.base.token_program,
            },
            false => Deposit {
                event_authority: event_authority::ID.into(),
                user,
                market_account: self.market,
                user_ata: self.get_quote_ata(&user),
                market_ata: self.quote_market_ata,
                mint: self.quote.mint,
                token_program: self.quote.token_program,
            },
        }
        .create_instruction(data)
    }

    fn withdraw(&self, user: Pubkey, data: WithdrawInstructionData, is_base: bool) -> Instruction {
        match is_base {
            true => Withdraw {
                event_authority: event_authority::ID.into(),
                user,
                market_account: self.market,
                user_ata: self.get_base_ata(&user),
                market_ata: self.base_market_ata,
                mint: self.base.mint,
                token_program: self.base.token_program,
            },
            false => Withdraw {
                event_authority: event_authority::ID.into(),
                user,
                market_account: self.market,
                user_ata: self.get_quote_ata(&user),
                market_ata: self.quote_market_ata,
                mint: self.quote.mint,
                token_program: self.quote.token_program,
            },
        }
        .create_instruction(data)
    }
}
