//! Market-level context for creating markets, managing seats, and building `dropset` market
//! instructions.

use dropset_interface::{
    instructions::{
        generated_client::*,
        CancelOrderInstructionData,
        CloseSeatInstructionData,
        DepositInstructionData,
        PostOrderInstructionData,
        RegisterMarketInstructionData,
        WithdrawInstructionData,
    },
    seeds::event_authority,
    state::{
        sector::NIL,
        SYSTEM_PROGRAM_ID,
    },
};
use solana_sdk::pubkey::Pubkey;
use transaction_parser::views::{
    try_market_view_all_from_owner_and_data,
    MarketSeatView,
    MarketViewAll,
};

use crate::{
    context::token::TokenContext,
    pda::find_market_address,
    single_signer_instruction::SingleSignerInstruction,
    transactions::CustomRpcClient,
};

/// A struct containing contextual fields for a market.
///
/// Implements helper methods for all program instructions using those values.
pub struct MarketContext {
    pub market: Pubkey,
    pub base: TokenContext,
    pub quote: TokenContext,
    pub base_market_ata: Pubkey,
    pub quote_market_ata: Pubkey,
}

impl MarketContext {
    /// Creates a market with random tokens generated by airdropping funds.
    pub async fn new_market(rpc: &CustomRpcClient) -> anyhow::Result<Self> {
        let base = TokenContext::new_token(rpc, None).await?;
        let quote = TokenContext::new_token(rpc, None).await?;
        let (market_address, _bump) = find_market_address(&base.mint, &quote.mint);
        let base_market_ata = base.get_ata_for(&market_address);
        let quote_market_ata = quote.get_ata_for(&market_address);
        Ok(Self {
            market: market_address,
            base,
            quote,
            base_market_ata,
            quote_market_ata,
        })
    }

    pub fn get_base_ata(&self, owner: &Pubkey) -> Pubkey {
        self.base.get_ata_for(owner)
    }

    pub fn get_quote_ata(&self, owner: &Pubkey) -> Pubkey {
        self.quote.get_ata_for(owner)
    }

    /// Creates a seat for the user by depositing the minimum amount required to create a seat.
    ///
    /// This is because the amount cannot be zero:
    /// [`dropset_interface::error::DropsetError::AmountCannotBeZero`]
    pub fn create_seat(&self, user: Pubkey) -> SingleSignerInstruction {
        self.deposit_base(user, 1, NIL)
    }

    pub fn register_market(&self, payer: Pubkey, num_sectors: u16) -> SingleSignerInstruction {
        RegisterMarket {
            event_authority: event_authority::ID.into(),
            user: payer,
            market_account: self.market,
            base_market_ata: self.base_market_ata,
            quote_market_ata: self.quote_market_ata,
            base_mint: self.base.mint,
            quote_mint: self.quote.mint,
            base_token_program: self.base.token_program,
            quote_token_program: self.quote.token_program,
            ata_program: spl_associated_token_account_interface::program::ID,
            system_program: SYSTEM_PROGRAM_ID.into(),
            dropset_program: dropset::ID.into(),
        }
        .create_instruction(RegisterMarketInstructionData::new(num_sectors))
        .try_into()
        .expect("Should be a single signer instruction")
    }

    pub fn view_market(&self, rpc: &CustomRpcClient) -> anyhow::Result<MarketViewAll> {
        let market_account = rpc.client.get_account(&self.market)?;
        try_market_view_all_from_owner_and_data(market_account.owner, &market_account.data)
    }

    pub fn find_seat(
        &self,
        rpc: &CustomRpcClient,
        user: &Pubkey,
    ) -> anyhow::Result<Option<MarketSeatView>> {
        let market_seats = self.view_market(rpc)?.seats;
        Ok(market_seats.into_iter().find(|seat| &seat.user == user))
    }

    pub fn close_seat(&self, user: Pubkey, sector_index_hint: u32) -> SingleSignerInstruction {
        CloseSeat {
            event_authority: event_authority::ID.into(),
            user,
            market_account: self.market,
            base_user_ata: self.get_base_ata(&user),
            quote_user_ata: self.get_quote_ata(&user),
            base_market_ata: self.base_market_ata,
            quote_market_ata: self.quote_market_ata,
            base_mint: self.base.mint,
            quote_mint: self.quote.mint,
            base_token_program: self.base.token_program,
            quote_token_program: self.quote.token_program,
            dropset_program: dropset::ID.into(),
        }
        .create_instruction(CloseSeatInstructionData::new(sector_index_hint))
        .try_into()
        .expect("Should be a single signer instruction")
    }

    pub fn deposit_base(
        &self,
        user: Pubkey,
        amount: u64,
        sector_index_hint: u32,
    ) -> SingleSignerInstruction {
        let data = DepositInstructionData::new(amount, sector_index_hint);
        self.deposit(user, data, true)
    }

    pub fn deposit_quote(
        &self,
        user: Pubkey,
        amount: u64,
        sector_index_hint: u32,
    ) -> SingleSignerInstruction {
        let data = DepositInstructionData::new(amount, sector_index_hint);
        self.deposit(user, data, false)
    }

    pub fn withdraw_base(
        &self,
        user: Pubkey,
        amount: u64,
        sector_index_hint: u32,
    ) -> SingleSignerInstruction {
        let data = WithdrawInstructionData::new(amount, sector_index_hint);
        self.withdraw(user, data, true)
    }

    pub fn withdraw_quote(
        &self,
        user: Pubkey,
        amount: u64,
        sector_index_hint: u32,
    ) -> SingleSignerInstruction {
        let data = WithdrawInstructionData::new(amount, sector_index_hint);
        self.withdraw(user, data, false)
    }

    pub fn post_order(
        &self,
        user: Pubkey,
        data: PostOrderInstructionData,
    ) -> SingleSignerInstruction {
        PostOrder {
            event_authority: event_authority::ID.into(),
            user,
            market_account: self.market,
            dropset_program: dropset::ID.into(),
        }
        .create_instruction(data)
        .try_into()
        .expect("Should be a single signer instruction")
    }

    pub fn cancel_order(
        &self,
        user: Pubkey,
        data: CancelOrderInstructionData,
    ) -> SingleSignerInstruction {
        CancelOrder {
            event_authority: event_authority::ID.into(),
            user,
            market_account: self.market,
            dropset_program: dropset::ID.into(),
        }
        .create_instruction(data)
        .try_into()
        .expect("Should be a single signer instruction")
    }

    fn deposit(
        &self,
        user: Pubkey,
        data: DepositInstructionData,
        is_base: bool,
    ) -> SingleSignerInstruction {
        match is_base {
            true => Deposit {
                event_authority: event_authority::ID.into(),
                user,
                market_account: self.market,
                user_ata: self.get_base_ata(&user),
                market_ata: self.base_market_ata,
                mint: self.base.mint,
                token_program: self.base.token_program,
                dropset_program: dropset::ID.into(),
            },
            false => Deposit {
                event_authority: event_authority::ID.into(),
                user,
                market_account: self.market,
                user_ata: self.get_quote_ata(&user),
                market_ata: self.quote_market_ata,
                mint: self.quote.mint,
                token_program: self.quote.token_program,
                dropset_program: dropset::ID.into(),
            },
        }
        .create_instruction(data)
        .try_into()
        .expect("Should be a single signer instruction")
    }

    fn withdraw(
        &self,
        user: Pubkey,
        data: WithdrawInstructionData,
        is_base: bool,
    ) -> SingleSignerInstruction {
        match is_base {
            true => Withdraw {
                event_authority: event_authority::ID.into(),
                user,
                market_account: self.market,
                user_ata: self.get_base_ata(&user),
                market_ata: self.base_market_ata,
                mint: self.base.mint,
                token_program: self.base.token_program,
                dropset_program: dropset::ID.into(),
            },
            false => Withdraw {
                event_authority: event_authority::ID.into(),
                user,
                market_account: self.market,
                user_ata: self.get_quote_ata(&user),
                market_ata: self.quote_market_ata,
                mint: self.quote.mint,
                token_program: self.quote.token_program,
                dropset_program: dropset::ID.into(),
            },
        }
        .create_instruction(data)
        .try_into()
        .expect("Should be a single signer instruction")
    }
}
